// This file was generated by counterfeiter
package gometricspcffakes

import (
	"sync"
	"time"

	"github.com/rcrowley/go-metrics"
)

type FakeTimer struct {
	CountStub        func() int64
	countMutex       sync.RWMutex
	countArgsForCall []struct{}
	countReturns     struct {
		result1 int64
	}
	countReturnsOnCall map[int]struct {
		result1 int64
	}
	MaxStub        func() int64
	maxMutex       sync.RWMutex
	maxArgsForCall []struct{}
	maxReturns     struct {
		result1 int64
	}
	maxReturnsOnCall map[int]struct {
		result1 int64
	}
	MeanStub        func() float64
	meanMutex       sync.RWMutex
	meanArgsForCall []struct{}
	meanReturns     struct {
		result1 float64
	}
	meanReturnsOnCall map[int]struct {
		result1 float64
	}
	MinStub        func() int64
	minMutex       sync.RWMutex
	minArgsForCall []struct{}
	minReturns     struct {
		result1 int64
	}
	minReturnsOnCall map[int]struct {
		result1 int64
	}
	PercentileStub        func(float64) float64
	percentileMutex       sync.RWMutex
	percentileArgsForCall []struct {
		arg1 float64
	}
	percentileReturns struct {
		result1 float64
	}
	percentileReturnsOnCall map[int]struct {
		result1 float64
	}
	PercentilesStub        func([]float64) []float64
	percentilesMutex       sync.RWMutex
	percentilesArgsForCall []struct {
		arg1 []float64
	}
	percentilesReturns struct {
		result1 []float64
	}
	percentilesReturnsOnCall map[int]struct {
		result1 []float64
	}
	Rate1Stub        func() float64
	rate1Mutex       sync.RWMutex
	rate1ArgsForCall []struct{}
	rate1Returns     struct {
		result1 float64
	}
	rate1ReturnsOnCall map[int]struct {
		result1 float64
	}
	Rate5Stub        func() float64
	rate5Mutex       sync.RWMutex
	rate5ArgsForCall []struct{}
	rate5Returns     struct {
		result1 float64
	}
	rate5ReturnsOnCall map[int]struct {
		result1 float64
	}
	Rate15Stub        func() float64
	rate15Mutex       sync.RWMutex
	rate15ArgsForCall []struct{}
	rate15Returns     struct {
		result1 float64
	}
	rate15ReturnsOnCall map[int]struct {
		result1 float64
	}
	RateMeanStub        func() float64
	rateMeanMutex       sync.RWMutex
	rateMeanArgsForCall []struct{}
	rateMeanReturns     struct {
		result1 float64
	}
	rateMeanReturnsOnCall map[int]struct {
		result1 float64
	}
	SnapshotStub        func() metrics.Timer
	snapshotMutex       sync.RWMutex
	snapshotArgsForCall []struct{}
	snapshotReturns     struct {
		result1 metrics.Timer
	}
	snapshotReturnsOnCall map[int]struct {
		result1 metrics.Timer
	}
	StdDevStub        func() float64
	stdDevMutex       sync.RWMutex
	stdDevArgsForCall []struct{}
	stdDevReturns     struct {
		result1 float64
	}
	stdDevReturnsOnCall map[int]struct {
		result1 float64
	}
	SumStub        func() int64
	sumMutex       sync.RWMutex
	sumArgsForCall []struct{}
	sumReturns     struct {
		result1 int64
	}
	sumReturnsOnCall map[int]struct {
		result1 int64
	}
	TimeStub        func(func())
	timeMutex       sync.RWMutex
	timeArgsForCall []struct {
		arg1 func()
	}
	UpdateStub        func(time.Duration)
	updateMutex       sync.RWMutex
	updateArgsForCall []struct {
		arg1 time.Duration
	}
	UpdateSinceStub        func(time.Time)
	updateSinceMutex       sync.RWMutex
	updateSinceArgsForCall []struct {
		arg1 time.Time
	}
	VarianceStub        func() float64
	varianceMutex       sync.RWMutex
	varianceArgsForCall []struct{}
	varianceReturns     struct {
		result1 float64
	}
	varianceReturnsOnCall map[int]struct {
		result1 float64
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeTimer) Count() int64 {
	fake.countMutex.Lock()
	ret, specificReturn := fake.countReturnsOnCall[len(fake.countArgsForCall)]
	fake.countArgsForCall = append(fake.countArgsForCall, struct{}{})
	fake.recordInvocation("Count", []interface{}{})
	fake.countMutex.Unlock()
	if fake.CountStub != nil {
		return fake.CountStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.countReturns.result1
}

func (fake *FakeTimer) CountCallCount() int {
	fake.countMutex.RLock()
	defer fake.countMutex.RUnlock()
	return len(fake.countArgsForCall)
}

func (fake *FakeTimer) CountReturns(result1 int64) {
	fake.CountStub = nil
	fake.countReturns = struct {
		result1 int64
	}{result1}
}

func (fake *FakeTimer) CountReturnsOnCall(i int, result1 int64) {
	fake.CountStub = nil
	if fake.countReturnsOnCall == nil {
		fake.countReturnsOnCall = make(map[int]struct {
			result1 int64
		})
	}
	fake.countReturnsOnCall[i] = struct {
		result1 int64
	}{result1}
}

func (fake *FakeTimer) Max() int64 {
	fake.maxMutex.Lock()
	ret, specificReturn := fake.maxReturnsOnCall[len(fake.maxArgsForCall)]
	fake.maxArgsForCall = append(fake.maxArgsForCall, struct{}{})
	fake.recordInvocation("Max", []interface{}{})
	fake.maxMutex.Unlock()
	if fake.MaxStub != nil {
		return fake.MaxStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.maxReturns.result1
}

func (fake *FakeTimer) MaxCallCount() int {
	fake.maxMutex.RLock()
	defer fake.maxMutex.RUnlock()
	return len(fake.maxArgsForCall)
}

func (fake *FakeTimer) MaxReturns(result1 int64) {
	fake.MaxStub = nil
	fake.maxReturns = struct {
		result1 int64
	}{result1}
}

func (fake *FakeTimer) MaxReturnsOnCall(i int, result1 int64) {
	fake.MaxStub = nil
	if fake.maxReturnsOnCall == nil {
		fake.maxReturnsOnCall = make(map[int]struct {
			result1 int64
		})
	}
	fake.maxReturnsOnCall[i] = struct {
		result1 int64
	}{result1}
}

func (fake *FakeTimer) Mean() float64 {
	fake.meanMutex.Lock()
	ret, specificReturn := fake.meanReturnsOnCall[len(fake.meanArgsForCall)]
	fake.meanArgsForCall = append(fake.meanArgsForCall, struct{}{})
	fake.recordInvocation("Mean", []interface{}{})
	fake.meanMutex.Unlock()
	if fake.MeanStub != nil {
		return fake.MeanStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.meanReturns.result1
}

func (fake *FakeTimer) MeanCallCount() int {
	fake.meanMutex.RLock()
	defer fake.meanMutex.RUnlock()
	return len(fake.meanArgsForCall)
}

func (fake *FakeTimer) MeanReturns(result1 float64) {
	fake.MeanStub = nil
	fake.meanReturns = struct {
		result1 float64
	}{result1}
}

func (fake *FakeTimer) MeanReturnsOnCall(i int, result1 float64) {
	fake.MeanStub = nil
	if fake.meanReturnsOnCall == nil {
		fake.meanReturnsOnCall = make(map[int]struct {
			result1 float64
		})
	}
	fake.meanReturnsOnCall[i] = struct {
		result1 float64
	}{result1}
}

func (fake *FakeTimer) Min() int64 {
	fake.minMutex.Lock()
	ret, specificReturn := fake.minReturnsOnCall[len(fake.minArgsForCall)]
	fake.minArgsForCall = append(fake.minArgsForCall, struct{}{})
	fake.recordInvocation("Min", []interface{}{})
	fake.minMutex.Unlock()
	if fake.MinStub != nil {
		return fake.MinStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.minReturns.result1
}

func (fake *FakeTimer) MinCallCount() int {
	fake.minMutex.RLock()
	defer fake.minMutex.RUnlock()
	return len(fake.minArgsForCall)
}

func (fake *FakeTimer) MinReturns(result1 int64) {
	fake.MinStub = nil
	fake.minReturns = struct {
		result1 int64
	}{result1}
}

func (fake *FakeTimer) MinReturnsOnCall(i int, result1 int64) {
	fake.MinStub = nil
	if fake.minReturnsOnCall == nil {
		fake.minReturnsOnCall = make(map[int]struct {
			result1 int64
		})
	}
	fake.minReturnsOnCall[i] = struct {
		result1 int64
	}{result1}
}

func (fake *FakeTimer) Percentile(arg1 float64) float64 {
	fake.percentileMutex.Lock()
	ret, specificReturn := fake.percentileReturnsOnCall[len(fake.percentileArgsForCall)]
	fake.percentileArgsForCall = append(fake.percentileArgsForCall, struct {
		arg1 float64
	}{arg1})
	fake.recordInvocation("Percentile", []interface{}{arg1})
	fake.percentileMutex.Unlock()
	if fake.PercentileStub != nil {
		return fake.PercentileStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.percentileReturns.result1
}

func (fake *FakeTimer) PercentileCallCount() int {
	fake.percentileMutex.RLock()
	defer fake.percentileMutex.RUnlock()
	return len(fake.percentileArgsForCall)
}

func (fake *FakeTimer) PercentileArgsForCall(i int) float64 {
	fake.percentileMutex.RLock()
	defer fake.percentileMutex.RUnlock()
	return fake.percentileArgsForCall[i].arg1
}

func (fake *FakeTimer) PercentileReturns(result1 float64) {
	fake.PercentileStub = nil
	fake.percentileReturns = struct {
		result1 float64
	}{result1}
}

func (fake *FakeTimer) PercentileReturnsOnCall(i int, result1 float64) {
	fake.PercentileStub = nil
	if fake.percentileReturnsOnCall == nil {
		fake.percentileReturnsOnCall = make(map[int]struct {
			result1 float64
		})
	}
	fake.percentileReturnsOnCall[i] = struct {
		result1 float64
	}{result1}
}

func (fake *FakeTimer) Percentiles(arg1 []float64) []float64 {
	var arg1Copy []float64
	if arg1 != nil {
		arg1Copy = make([]float64, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.percentilesMutex.Lock()
	ret, specificReturn := fake.percentilesReturnsOnCall[len(fake.percentilesArgsForCall)]
	fake.percentilesArgsForCall = append(fake.percentilesArgsForCall, struct {
		arg1 []float64
	}{arg1Copy})
	fake.recordInvocation("Percentiles", []interface{}{arg1Copy})
	fake.percentilesMutex.Unlock()
	if fake.PercentilesStub != nil {
		return fake.PercentilesStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.percentilesReturns.result1
}

func (fake *FakeTimer) PercentilesCallCount() int {
	fake.percentilesMutex.RLock()
	defer fake.percentilesMutex.RUnlock()
	return len(fake.percentilesArgsForCall)
}

func (fake *FakeTimer) PercentilesArgsForCall(i int) []float64 {
	fake.percentilesMutex.RLock()
	defer fake.percentilesMutex.RUnlock()
	return fake.percentilesArgsForCall[i].arg1
}

func (fake *FakeTimer) PercentilesReturns(result1 []float64) {
	fake.PercentilesStub = nil
	fake.percentilesReturns = struct {
		result1 []float64
	}{result1}
}

func (fake *FakeTimer) PercentilesReturnsOnCall(i int, result1 []float64) {
	fake.PercentilesStub = nil
	if fake.percentilesReturnsOnCall == nil {
		fake.percentilesReturnsOnCall = make(map[int]struct {
			result1 []float64
		})
	}
	fake.percentilesReturnsOnCall[i] = struct {
		result1 []float64
	}{result1}
}

func (fake *FakeTimer) Rate1() float64 {
	fake.rate1Mutex.Lock()
	ret, specificReturn := fake.rate1ReturnsOnCall[len(fake.rate1ArgsForCall)]
	fake.rate1ArgsForCall = append(fake.rate1ArgsForCall, struct{}{})
	fake.recordInvocation("Rate1", []interface{}{})
	fake.rate1Mutex.Unlock()
	if fake.Rate1Stub != nil {
		return fake.Rate1Stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.rate1Returns.result1
}

func (fake *FakeTimer) Rate1CallCount() int {
	fake.rate1Mutex.RLock()
	defer fake.rate1Mutex.RUnlock()
	return len(fake.rate1ArgsForCall)
}

func (fake *FakeTimer) Rate1Returns(result1 float64) {
	fake.Rate1Stub = nil
	fake.rate1Returns = struct {
		result1 float64
	}{result1}
}

func (fake *FakeTimer) Rate1ReturnsOnCall(i int, result1 float64) {
	fake.Rate1Stub = nil
	if fake.rate1ReturnsOnCall == nil {
		fake.rate1ReturnsOnCall = make(map[int]struct {
			result1 float64
		})
	}
	fake.rate1ReturnsOnCall[i] = struct {
		result1 float64
	}{result1}
}

func (fake *FakeTimer) Rate5() float64 {
	fake.rate5Mutex.Lock()
	ret, specificReturn := fake.rate5ReturnsOnCall[len(fake.rate5ArgsForCall)]
	fake.rate5ArgsForCall = append(fake.rate5ArgsForCall, struct{}{})
	fake.recordInvocation("Rate5", []interface{}{})
	fake.rate5Mutex.Unlock()
	if fake.Rate5Stub != nil {
		return fake.Rate5Stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.rate5Returns.result1
}

func (fake *FakeTimer) Rate5CallCount() int {
	fake.rate5Mutex.RLock()
	defer fake.rate5Mutex.RUnlock()
	return len(fake.rate5ArgsForCall)
}

func (fake *FakeTimer) Rate5Returns(result1 float64) {
	fake.Rate5Stub = nil
	fake.rate5Returns = struct {
		result1 float64
	}{result1}
}

func (fake *FakeTimer) Rate5ReturnsOnCall(i int, result1 float64) {
	fake.Rate5Stub = nil
	if fake.rate5ReturnsOnCall == nil {
		fake.rate5ReturnsOnCall = make(map[int]struct {
			result1 float64
		})
	}
	fake.rate5ReturnsOnCall[i] = struct {
		result1 float64
	}{result1}
}

func (fake *FakeTimer) Rate15() float64 {
	fake.rate15Mutex.Lock()
	ret, specificReturn := fake.rate15ReturnsOnCall[len(fake.rate15ArgsForCall)]
	fake.rate15ArgsForCall = append(fake.rate15ArgsForCall, struct{}{})
	fake.recordInvocation("Rate15", []interface{}{})
	fake.rate15Mutex.Unlock()
	if fake.Rate15Stub != nil {
		return fake.Rate15Stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.rate15Returns.result1
}

func (fake *FakeTimer) Rate15CallCount() int {
	fake.rate15Mutex.RLock()
	defer fake.rate15Mutex.RUnlock()
	return len(fake.rate15ArgsForCall)
}

func (fake *FakeTimer) Rate15Returns(result1 float64) {
	fake.Rate15Stub = nil
	fake.rate15Returns = struct {
		result1 float64
	}{result1}
}

func (fake *FakeTimer) Rate15ReturnsOnCall(i int, result1 float64) {
	fake.Rate15Stub = nil
	if fake.rate15ReturnsOnCall == nil {
		fake.rate15ReturnsOnCall = make(map[int]struct {
			result1 float64
		})
	}
	fake.rate15ReturnsOnCall[i] = struct {
		result1 float64
	}{result1}
}

func (fake *FakeTimer) RateMean() float64 {
	fake.rateMeanMutex.Lock()
	ret, specificReturn := fake.rateMeanReturnsOnCall[len(fake.rateMeanArgsForCall)]
	fake.rateMeanArgsForCall = append(fake.rateMeanArgsForCall, struct{}{})
	fake.recordInvocation("RateMean", []interface{}{})
	fake.rateMeanMutex.Unlock()
	if fake.RateMeanStub != nil {
		return fake.RateMeanStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.rateMeanReturns.result1
}

func (fake *FakeTimer) RateMeanCallCount() int {
	fake.rateMeanMutex.RLock()
	defer fake.rateMeanMutex.RUnlock()
	return len(fake.rateMeanArgsForCall)
}

func (fake *FakeTimer) RateMeanReturns(result1 float64) {
	fake.RateMeanStub = nil
	fake.rateMeanReturns = struct {
		result1 float64
	}{result1}
}

func (fake *FakeTimer) RateMeanReturnsOnCall(i int, result1 float64) {
	fake.RateMeanStub = nil
	if fake.rateMeanReturnsOnCall == nil {
		fake.rateMeanReturnsOnCall = make(map[int]struct {
			result1 float64
		})
	}
	fake.rateMeanReturnsOnCall[i] = struct {
		result1 float64
	}{result1}
}

func (fake *FakeTimer) Snapshot() metrics.Timer {
	fake.snapshotMutex.Lock()
	ret, specificReturn := fake.snapshotReturnsOnCall[len(fake.snapshotArgsForCall)]
	fake.snapshotArgsForCall = append(fake.snapshotArgsForCall, struct{}{})
	fake.recordInvocation("Snapshot", []interface{}{})
	fake.snapshotMutex.Unlock()
	if fake.SnapshotStub != nil {
		return fake.SnapshotStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.snapshotReturns.result1
}

func (fake *FakeTimer) SnapshotCallCount() int {
	fake.snapshotMutex.RLock()
	defer fake.snapshotMutex.RUnlock()
	return len(fake.snapshotArgsForCall)
}

func (fake *FakeTimer) SnapshotReturns(result1 metrics.Timer) {
	fake.SnapshotStub = nil
	fake.snapshotReturns = struct {
		result1 metrics.Timer
	}{result1}
}

func (fake *FakeTimer) SnapshotReturnsOnCall(i int, result1 metrics.Timer) {
	fake.SnapshotStub = nil
	if fake.snapshotReturnsOnCall == nil {
		fake.snapshotReturnsOnCall = make(map[int]struct {
			result1 metrics.Timer
		})
	}
	fake.snapshotReturnsOnCall[i] = struct {
		result1 metrics.Timer
	}{result1}
}

func (fake *FakeTimer) StdDev() float64 {
	fake.stdDevMutex.Lock()
	ret, specificReturn := fake.stdDevReturnsOnCall[len(fake.stdDevArgsForCall)]
	fake.stdDevArgsForCall = append(fake.stdDevArgsForCall, struct{}{})
	fake.recordInvocation("StdDev", []interface{}{})
	fake.stdDevMutex.Unlock()
	if fake.StdDevStub != nil {
		return fake.StdDevStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.stdDevReturns.result1
}

func (fake *FakeTimer) StdDevCallCount() int {
	fake.stdDevMutex.RLock()
	defer fake.stdDevMutex.RUnlock()
	return len(fake.stdDevArgsForCall)
}

func (fake *FakeTimer) StdDevReturns(result1 float64) {
	fake.StdDevStub = nil
	fake.stdDevReturns = struct {
		result1 float64
	}{result1}
}

func (fake *FakeTimer) StdDevReturnsOnCall(i int, result1 float64) {
	fake.StdDevStub = nil
	if fake.stdDevReturnsOnCall == nil {
		fake.stdDevReturnsOnCall = make(map[int]struct {
			result1 float64
		})
	}
	fake.stdDevReturnsOnCall[i] = struct {
		result1 float64
	}{result1}
}

func (fake *FakeTimer) Sum() int64 {
	fake.sumMutex.Lock()
	ret, specificReturn := fake.sumReturnsOnCall[len(fake.sumArgsForCall)]
	fake.sumArgsForCall = append(fake.sumArgsForCall, struct{}{})
	fake.recordInvocation("Sum", []interface{}{})
	fake.sumMutex.Unlock()
	if fake.SumStub != nil {
		return fake.SumStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.sumReturns.result1
}

func (fake *FakeTimer) SumCallCount() int {
	fake.sumMutex.RLock()
	defer fake.sumMutex.RUnlock()
	return len(fake.sumArgsForCall)
}

func (fake *FakeTimer) SumReturns(result1 int64) {
	fake.SumStub = nil
	fake.sumReturns = struct {
		result1 int64
	}{result1}
}

func (fake *FakeTimer) SumReturnsOnCall(i int, result1 int64) {
	fake.SumStub = nil
	if fake.sumReturnsOnCall == nil {
		fake.sumReturnsOnCall = make(map[int]struct {
			result1 int64
		})
	}
	fake.sumReturnsOnCall[i] = struct {
		result1 int64
	}{result1}
}

func (fake *FakeTimer) Time(arg1 func()) {
	fake.timeMutex.Lock()
	fake.timeArgsForCall = append(fake.timeArgsForCall, struct {
		arg1 func()
	}{arg1})
	fake.recordInvocation("Time", []interface{}{arg1})
	fake.timeMutex.Unlock()
	if fake.TimeStub != nil {
		fake.TimeStub(arg1)
	}
}

func (fake *FakeTimer) TimeCallCount() int {
	fake.timeMutex.RLock()
	defer fake.timeMutex.RUnlock()
	return len(fake.timeArgsForCall)
}

func (fake *FakeTimer) TimeArgsForCall(i int) func() {
	fake.timeMutex.RLock()
	defer fake.timeMutex.RUnlock()
	return fake.timeArgsForCall[i].arg1
}

func (fake *FakeTimer) Update(arg1 time.Duration) {
	fake.updateMutex.Lock()
	fake.updateArgsForCall = append(fake.updateArgsForCall, struct {
		arg1 time.Duration
	}{arg1})
	fake.recordInvocation("Update", []interface{}{arg1})
	fake.updateMutex.Unlock()
	if fake.UpdateStub != nil {
		fake.UpdateStub(arg1)
	}
}

func (fake *FakeTimer) UpdateCallCount() int {
	fake.updateMutex.RLock()
	defer fake.updateMutex.RUnlock()
	return len(fake.updateArgsForCall)
}

func (fake *FakeTimer) UpdateArgsForCall(i int) time.Duration {
	fake.updateMutex.RLock()
	defer fake.updateMutex.RUnlock()
	return fake.updateArgsForCall[i].arg1
}

func (fake *FakeTimer) UpdateSince(arg1 time.Time) {
	fake.updateSinceMutex.Lock()
	fake.updateSinceArgsForCall = append(fake.updateSinceArgsForCall, struct {
		arg1 time.Time
	}{arg1})
	fake.recordInvocation("UpdateSince", []interface{}{arg1})
	fake.updateSinceMutex.Unlock()
	if fake.UpdateSinceStub != nil {
		fake.UpdateSinceStub(arg1)
	}
}

func (fake *FakeTimer) UpdateSinceCallCount() int {
	fake.updateSinceMutex.RLock()
	defer fake.updateSinceMutex.RUnlock()
	return len(fake.updateSinceArgsForCall)
}

func (fake *FakeTimer) UpdateSinceArgsForCall(i int) time.Time {
	fake.updateSinceMutex.RLock()
	defer fake.updateSinceMutex.RUnlock()
	return fake.updateSinceArgsForCall[i].arg1
}

func (fake *FakeTimer) Variance() float64 {
	fake.varianceMutex.Lock()
	ret, specificReturn := fake.varianceReturnsOnCall[len(fake.varianceArgsForCall)]
	fake.varianceArgsForCall = append(fake.varianceArgsForCall, struct{}{})
	fake.recordInvocation("Variance", []interface{}{})
	fake.varianceMutex.Unlock()
	if fake.VarianceStub != nil {
		return fake.VarianceStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.varianceReturns.result1
}

func (fake *FakeTimer) VarianceCallCount() int {
	fake.varianceMutex.RLock()
	defer fake.varianceMutex.RUnlock()
	return len(fake.varianceArgsForCall)
}

func (fake *FakeTimer) VarianceReturns(result1 float64) {
	fake.VarianceStub = nil
	fake.varianceReturns = struct {
		result1 float64
	}{result1}
}

func (fake *FakeTimer) VarianceReturnsOnCall(i int, result1 float64) {
	fake.VarianceStub = nil
	if fake.varianceReturnsOnCall == nil {
		fake.varianceReturnsOnCall = make(map[int]struct {
			result1 float64
		})
	}
	fake.varianceReturnsOnCall[i] = struct {
		result1 float64
	}{result1}
}

func (fake *FakeTimer) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.countMutex.RLock()
	defer fake.countMutex.RUnlock()
	fake.maxMutex.RLock()
	defer fake.maxMutex.RUnlock()
	fake.meanMutex.RLock()
	defer fake.meanMutex.RUnlock()
	fake.minMutex.RLock()
	defer fake.minMutex.RUnlock()
	fake.percentileMutex.RLock()
	defer fake.percentileMutex.RUnlock()
	fake.percentilesMutex.RLock()
	defer fake.percentilesMutex.RUnlock()
	fake.rate1Mutex.RLock()
	defer fake.rate1Mutex.RUnlock()
	fake.rate5Mutex.RLock()
	defer fake.rate5Mutex.RUnlock()
	fake.rate15Mutex.RLock()
	defer fake.rate15Mutex.RUnlock()
	fake.rateMeanMutex.RLock()
	defer fake.rateMeanMutex.RUnlock()
	fake.snapshotMutex.RLock()
	defer fake.snapshotMutex.RUnlock()
	fake.stdDevMutex.RLock()
	defer fake.stdDevMutex.RUnlock()
	fake.sumMutex.RLock()
	defer fake.sumMutex.RUnlock()
	fake.timeMutex.RLock()
	defer fake.timeMutex.RUnlock()
	fake.updateMutex.RLock()
	defer fake.updateMutex.RUnlock()
	fake.updateSinceMutex.RLock()
	defer fake.updateSinceMutex.RUnlock()
	fake.varianceMutex.RLock()
	defer fake.varianceMutex.RUnlock()
	return fake.invocations
}

func (fake *FakeTimer) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ metrics.Timer = new(FakeTimer)
